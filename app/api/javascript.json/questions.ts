import { type QuestionWithoutId } from '@/shared/types';

export const questions: QuestionWithoutId[] = [
	{
		title: 'Объясните делегирование событий.',
		answer:
			'Всплытие событий позволяет реализовать один из самых важных приёмов разработки - **делегирование**.  \n<br/> Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент *event.target*, понять на каком потомке произошло событие и обработать его.  \n<br/> **Алгоритм:**  \n 1. Вешаем обработчик на контейнер.  \n 2. В обработчике: получаем event.target.  \n 3. В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.  \n<br/> **Зачем использовать:**  \n 1. Упрощает инициализацию и экономит память: не нужно вешать много обработчиков. \n 2. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.  \n 3. Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.',
	},
	{
		title: 'Объясните, как this работает в JavaScript.',
		answer:
			'**this** в JavaScript - это специальное ключевое слово, которое ссылается на контекст выполнения функции. Его значение определяется тем, как функция была вызвана, а не где она объявлена.  \n<br/> Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.  \n<br/> Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.',
	},
	{
		title: 'Расскажите, как работает прототипное наследование.',
		answer:
			'Прототипом объекта А называется объект B, свойства и методы которого доступны для объекта A как собственные.<br/><br/> 1) У любого объекта есть прототип, на который указывает его свойство **__proto__** и который также является объектом.<br/>2) У любой функции есть ассоциированный с ней объект, на который в контексте функции указывает свойство prototype. В него как в контейнер обычно складывают свойства и методы для работы с определенным классом объектов.<br/>3) Такой контейнер автоматически становится прототипом объектов, создаваемых функциями-конструкторами<br/>4) Для редактирования прототипной ссылки объекта используют метод Object.create() - он перезаписывает объект заново и выставляет в нем ссылку на нужный прототип.  <br/>5) Ссылки связанных друг с другом объектов образуют прототипную цепочку, которая лежит в основе прототипного наследования. Ярким примером такого наследования является цепочка узлов DOM модели.<br/><br/> **Пример** <br/>`let animal = { eats: true, }; let rabbit = { jumps: true,};rabbit.__proto__ = animal; alert(rabbit.eats); alert(rabbit.jumps);`',
	},
];
