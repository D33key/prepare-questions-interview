import { type QuestionWithoutId } from '@/shared/types';

export const questions: QuestionWithoutId[] = [
	{
		title: 'Объясните делегирование событий.',
		answer:
			'Всплытие событий позволяет реализовать один из самых важных приёмов разработки - **делегирование**.  \n<br/> Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому - мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент *event.target*, понять на каком потомке произошло событие и обработать его.  \n<br/> **Алгоритм:**  \n 1. Вешаем обработчик на контейнер.  \n 2. В обработчике: получаем event.target.  \n 3. В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обрабатываем его.  \n<br/> **Зачем использовать:**  \n 1. Упрощает инициализацию и экономит память: не нужно вешать много обработчиков. \n 2. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.  \n 3. Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.',
	},
	{
		title: 'Объясните, как this работает в JavaScript.',
		answer:
			'**this** в JavaScript - это специальное ключевое слово, которое ссылается на контекст выполнения функции. Его значение определяется тем, как функция была вызвана, а не где она объявлена.  \n<br/> Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.  \n<br/> Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.',
	},
	{
		title: 'Расскажите, как работает прототипное наследование.',
		answer:
			'Прототипом объекта А называется объект B, свойства и методы которого доступны для объекта A как собственные.<br/><br/> 1) У любого объекта есть прототип, на который указывает его свойство **__proto__** и который также является объектом.<br/>2) У любой функции есть ассоциированный с ней объект, на который в контексте функции указывает свойство prototype. В него как в контейнер обычно складывают свойства и методы для работы с определенным классом объектов.<br/>3) Такой контейнер автоматически становится прототипом объектов, создаваемых функциями-конструкторами<br/>4) Для редактирования прототипной ссылки объекта используют метод Object.create() - он перезаписывает объект заново и выставляет в нем ссылку на нужный прототип.  <br/>5) Ссылки связанных друг с другом объектов образуют прототипную цепочку, которая лежит в основе прототипного наследования. Ярким примером такого наследования является цепочка узлов DOM модели.<br/><br/> **Пример** <br/>`let animal = { eats: true, }; let rabbit = { jumps: true,};rabbit.__proto__ = animal; alert(rabbit.eats); alert(rabbit.jumps);`',
	},
	{
		title: 'Объясните, почему это не является IIFE: function foo(){ }();',
		answer:
			'В этом примере будет выведено исключение SyntaxError, в данном случае это объявление функции и скобки в конце не будут отнесены к функции, так как они играют роль оператора группировки. Такие скобки не могут быть пустыми, поэтому будет выброшено исключение. Для того чтобы переделать этот пример под немедленно вызываему функцию - нужно обернуть функциональное выражение в скобки и удалить именование функции.',
	},
	{
		title:
			'В чём различие между переменными, значение которых: null, undefined и не объявлено?',
		answer:
			'**undefined** - это переменная, которая была объявлена, но у нее нет значения.<br/>**null** - значение переменной.<br/>**undeclared** - переменная, объявленная без ключевого слова *var*.<br/>Для проверки можно использовать console.log() и typeof.',
	},
	{
		title: 'Что такое замыкание и как/для чего его используют?',
		answer:
			'**Замыкание (closure)** - это одно из ключевых понятий JavaScript, которое позволяет функциям запоминать и получать доступ к переменным из своей лексической области видимости, даже когда эта функция выполняется вне своей исходной области видимости.<br/><br/> Когда функция создаётся внутри другой функции, она получает доступ к:<br/> 1)Своим локальным переменным<br/>2) Переменным внешней функции (в которой она была создана)<br/>3) Глобальным переменным<br/><br/>При этом, даже после того как внешняя функция завершила выполнение, внутренняя функция сохраняет доступ к переменным внешней функции.',
	},
	{
		title:
			'Можете ли вы описать основное различие между циклом forEach и циклом .map()? И в каких случаях каждый из них используется?',
		answer:
			'Оба метода используются для перебора элементов массива, но имеют ключевые различия в поведении и применении.<br/><br/>**forEach** используется, когда нужно:<br/>1) Выполнить операции с каждым элементом массива<br/> 2)Произвести side-эффекты (изменения вне массива)<br/>3)*Не нужно создавать новый массив*<br/><br/>**map()** используется, когда нужно:<br/>1)Преобразовать каждый элемент массива<br/>2)Создать новый массив на основе существующего<br/>3)Сохранить иммутабельность (не изменять исходный массив)',
	},
	{
		title: 'В каких случаях обычно используются анонимные функции?',
		answer:
			'Анонимные функции часто используются для выполнения какого-то кода в коллбэках, где не нужно создавать отдельную именную функцию под это действие.<br/><br/>**Преимущества анонимных функций**<br/>1)Локальная область видимости - переменные внутри не загрязняют глобальную область<br/>2)Удобство - не нужно придумывать имена для одноразовых функций<br/>3)Читаемость - когда функция небольшая и используется в одном месте<br/>4)Замыкания - сохраняют доступ к переменным внешней функции<br/><br/>**Когда лучше избегать анонимных функций**<br/>1)Когда функция сложная и многострочная - лучше дать имя для отладки<br/>2)Когда функция используется многократно - чтобы не дублировать код<br/>3)Когда нужна явная ссылка на функцию (например, для удаления обработчика событий)',
	},
	{
		title: 'В чём разница между host-объектами и нативными объектами?',
		answer:
			'**Собственные(Нативные) объекты**: *Object (конструктор)*, *Date*, *Math*, *parseInt*, *eval*, строковые методы, такие как *indexOf* и *replace*, методы массивов и т.д. - основные предопределённые объекты, всегда доступные в JavaScript. <br/><br/> **Объекты хоста (при условии среды браузера):** *window*, *document*, *location*, *history*, *XMLHttpRequest*, *setTimeout*, *getElementsByTagName*, *querySelectorAll* и т.д. - Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста.',
	},
	{
		title:
			'В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?',
		answer:
			'*function Person(){}* - Мы создаем функцию с именем Person.<br/>*var person = Person()* - Мы вызываем функцию Person и результат сохраняем в переменную person.<br/>*var person = new Person()* - Мы создаем новый объект, используя функцию-конструктор Person.',
	},
	{
		title: 'В чем разница между .call и .apply?',
		answer:
			'Сходство заключается в том, что и *.call*, и *.apply* используются для вызова функций, а также первый параметр будет использоваться как значение *this* внутри функции. А разница в том, что *.call* в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как *.apply* в качестве следующих аргументов принимает массив аргументов.<br/>`function add(a, b) { return a + b; } console.log(add.call(null, 1, 2));  console.log(add.apply(null, [1, 2]));`',
	},
	{
		title: 'Что делает и для чего нужна функция Function.prototype.bind?',
		answer:
			'Метод *bind()* создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения *this* предоставленное значение. В метод также передается набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при ее вызове.',
	},
	{
		title:
			'В чём разница между feature detection (определение возможностей), feature inference (предположение возможностей) и анализом строки user-agent?',
		answer:
			'**Feature detection (определение возможностей)** <br/>Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода — и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:<br/>`if ("geolocation" in navigator) {  } else {  }`<br/><br/>**Feature inference (предположение возможностей)** <br/>Предположение возможностей проверяет на наличие определённых возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определённая возможность уже существует, например:<br/>`if (document.getElementsByTagName) { element = document.getElementById(id); }`<br/>Этот подход не рекомендуеся. Первый подход более надёжен.<br/><br/>**Строка User Agent**<br/>Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя, от которого исходит запрос. Доступ к ней можно получить через navigator.userAgent. Тем не менее строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome и как Safari, нужно проверить на наличие строки Safari и отсутствие строки Chrome. Следует избегать этот метод.',
	},
	{
		title: 'Расскажите об Ajax как можно более подробно.',
		answer:
			'**AJAX (аббревиатура от "Asynchronous Javascript And Xml)** - технология обращения к серверу без перезагрузки страницы.<br/>За счёт этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп.<br/>Использовать XML не обязательно, под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.<br/><br/>**Элементы интерфейса**<br/>AJAX полезен для форм и кнопок, связанных с элементарными действиями: добавить в корзину, подписаться, и т.п.<br/><br/>**Динамическая подгрузка данных**<br/>Например, дерево, которое при раскрытии узла запрашивает данные у сервера.<br/><br/>**Живой поиск**<br/>Классический пример использования AJAX, взятый на вооружение современными поисковыми системами.<br/><br/>Обычно для обмена данными используются форматы:<br/>1)JSON - для отправки и получения структурированных данных, объектов.<br/>2)XML - если сервер почему-то работает в формате XML, то можно использовать и его.<br/>3)HTML/текст - можно и просто загрузить с сервера код HTML или текст для показа на странице.<br/>4)Бинарные данные, файлы - гораздо реже, в современных браузерах есть удобные средства для них.',
	},
	{
		title: 'Какие преимущества и недостатки в использовании Ajax?',
		answer:
			'**Преимущества**<br/>1)Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.<br/>2)Сокращение количества подключений к серверу, поскольку сткипты и таблицы стилей нужно запрашивать только один раз.<br/>3)Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.<br/><br/>**Недостатки**<br/>1)Сложнее реализовать добавление динамической веб-страницы в закладки.<br/>2)Не работает, если в браузере отключен JavaScript.<br/>3)Некоторые поисковые роботы не выполянют JS и не видят данные, загружаемые при помощи JS.',
	},
	{
		title: 'Объясните, как работает JSONP (и почему это не совсем AJAX).',
		answer:
			'**JSONP** - это способ, часто используемый для обхода политики ограничения домена в браузерах, потому что Ajax-запросы с текущей страницы к серверу, находящемуся в другом домене, запрещены.<br/><br/>JSONP работает, отправляя запрос к серверу в другом домене через тег *<script>* и обычно с параметром запроса callback, например: *https://example.com?callback=printData*. Затем сервер обернет данные внутри функции с именем *printData* и вернет их клиенту.<br/><br/>У клиента должна быть функция printData в своей глобальной области видимости, и эта функция будет выполена клиентом, когда будет получен ответ с сервера из другого домена.<br/><br/>JSONP может быть небезопасным. Нужно быть увереным в поставщике данных JSONP.',
	},
	{
		title: 'Расскажите, что такое поднятие (hoisting) переменных.',
		answer:
			'**Поднятие (hoisting)** — это термин, используемый для объяснения поведения объявлений переменных в коде. Переменные, объявленные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Поднимается только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.<br/>`console.log(foo); var foo = 1; console.log(foo);  console.log(bar); let bar = 2; console.log(bar);`<br/>При объявлении функции её тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.',
	},
	{
		title:
			'Объясните, что такое всплытие событий (event bubbling) и погружение. Для чего они нужны?',
		answer:
			'В DOM события распространяются в трех фазах:<br/>**Фаза погружения (Capturing Phase)** - событие движется сверху вниз от window к целевому элементу<br/>**Фаза цели (Target Phase)** - событие достигло целевого элемента<br/>**Фаза всплытия (Bubbling Phase)** - событие движется снизу вверх от целевого элемента к window<br/><br/>**Всплытие** - это процесс, при котором событие, возникшее на вложенном элементе, последовательно вызывается на всех его родительских элементах вверх по DOM-дереву.<br/><br/>**Погружение** - противоположный процесс, когда событие сначала обрабатывается на верхнем уровне (например, document), а затем последовательно спускается вниз до целевого элемента.<br/><br/>**Для чего нужны эти механизмы?**<br/>1)**Делегирование событий** - обработка событий на родительском элементе для множества дочерних элементов<br/>2)Контроль порядка обработки - возможность обработать событие до или после целевого элемента<br/>3)Глобальная обработка - перехват событий на верхнем уровне (например, для аналитики)<br/>4)Гибкость архитектуры - возможность централизованной обработки событий<br/><br/>**Как управлять распространением событий?**<br/>1)*event.stopPropagation()* - останавливает распространение события (но другие обработчики на этом же элементе сработают)<br/>2)*event.stopImmediatePropagation()* - полностью останавливает обработку события<br/>3)*event.preventDefault()* - отменяет стандартное поведение браузера (не влияет на распространение)',
	},
	{
		title:
			'В чём разница между «атрибутом» (attribute) и «свойством« (property)?',
		answer:
			'Атрибуты определены в разметке HTML, а свойства определены в DOM. Большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов. Но они не идентичны.<br/><br/>**Атрибуты**<br/>1)Всегда являются строками.<br/>2)Их имя нечувствительно к регистру.<br/>3)Видны в innerHTML.<br/><br/>**Свойства**<br/>1)Могут иметь любое значение.<br/>2)Названия свойств чувствительны к регистру.<br/>3)Работают за счёт того, что DOM-узлы являются объектами JS.',
	},
	{
		title: 'Почему не следует расширять нативные JavaScript-объекты?',
		answer:
			'Расширение встроенного (нативного) объекта JS означает добавление свойств (функций) к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Например, ваш код использует несколько библиотек, которые расширяют **Array.prototype**, добавляя один и тот же метод **contains**. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.<br/><br/>Единственный случай, при котором можно расширить нативный объект — это при создании полифила, создав собственную реализацию метода, который является частью спецификации JS, но может отстутствовать в устаревших браузерах.',
	},
	{
		title:
			'В чём разница между событием document load и событием document DOMContentLoaded?',
		answer:
			'Событие *DOMContentLoaded* вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.<br/><br/>Событие **load** происходит только после загрузки DOM и всех зависимых ресурсов.',
	},
	{
		title: 'В чём разница между == и ===?',
		answer:
			'**==** - это оператор абстрактного сравнения, а **===** - оператор строгого сравнения. Оператор == будет сравнивать на равенство после выполнения любых необходимых преобразований типов. Оператор === не будет выполнять преобразование типов, поэтому, если два занчения не одного типа, === просто вернет false.',
	},
	{
		title: 'Объясните same-origin policy в контексте JavaScript.',
		answer:
			'Same-Origin Policy (SOP) — это критически важный механизм безопасности в браузерах, который ограничивает взаимодействие между ресурсами с разных источников. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой страницы.',
	},
	{
		title:
			'Что делает строчка "use strict";? Какие достоинства и недостатки от её использования?',
		answer:
			'*use strict* это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.<br/><br/>**Преимущества**<br/>1)Не позволяет случайно создавать глобальные переменные.<br/>2)Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.<br/>3)При попытке удалить неудаляемые свойства выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).<br/>4)Требует, чтобы имена параметров функции были уникальными.<br/>5)this в глобальной области видимости равно undefined.<br/>6)Перехватывает распространённые ошибки, выдавая исключения.<br/>7)Исключает неочевидные особенности языка.<br/><br/>**Недостатки**<br/>1)Код, написанный для строгого режима, может не работать в его отсутствии<br/>2)Нет доступа к function.caller и function.arguments.',
	},
	{
		title:
			'Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?',
		answer:
			'Сохранение глобальной области видимости в чистоте — одно из фундаментальных правил качественной JavaScript-разработки. Вот основные причины этого:<br/>1)Предотвращение конфликтов имен<br/>2)Улучшение сопровождаемости кода (Глобальные переменные усложняют понимание кода, так как могут изменяться в любом месте программы)<br/>3)Безопасность(Злоумышленники могут получить доступ и изменить глобальные переменные (XSS-атаки))<br/>4)Производительность(Поиск переменных в цепочке областей видимости медленнее для глобальных переменных + Сборщик мусора не может освободить память, занятую глобальными переменными, пока работает приложение)<br/>5)Проблемы в больших приложениях(В сложных SPA-приложениях глобальные переменные становятся источником трудноуловимых багов)',
	},
	{
		title:
			'Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.',
		answer:
			'В наши дни веб-разработчики называют свои продукты веб-приложениями, а не веб-сайтами. Хотя между этими двумя терминами нет строгой разницы, веб-приложения, как правило, очень интерактивны и динамичны, что позволяет пользователю выполнять действия и получать мгновенный ответ. Традиционно браузер получает HTML с сервера и отображает его. Когда пользователь переходит на другой URL-адрес, требуется полное обновление страницы, и сервер отправляет свежий HTML-код на новую стрницу. Это называется рендерингом на стороне сервера.<br/><br/>Однако в современных SPA вместо этого используется рендеринг на стороне клиента. Браузер загружает начальную страницу с сервера вместе со скриптами (фреймворками, библиотеками, кодом приложения) и таблицами стилей, необходимыми для всего приложения. Когда пользовател переходит на другие страницы, обновление страницы не происходит. URL-адрес страницы обновляется при помощи HTML History API. Новые данные, необходимые для страницы (обычно в формате JSON), извлекаются браузером посредством запросов AJAX к серверу. Затем SPA динамически обновляет страницу данными через JavaScript, которые были получены при начальной загрузке страницы. Эта модель похожа на работу нативных мобильных приложений.<br/><br/>**Преимущества**<br/>1)Приложение становится более отзывчивым, и пользователи не видят мерцание при навигации, т.к. страница не обновляется целиком.<br/>2)На сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы не нужно загружать снова для каждой загрузки страницы.<br/>3)Чёткое разделение на клиент и сервер. Вы можете легко создавать новые клиентские приложения для разных платформ (например, для мобильных устройств, чат-ботов, умных часов) без необходимости изменять код сервера. Вы также можете изменить технологический стек на клиенте и сервере независимо, пока между ними существует интерфейс.<br/><br/>**Недостатки**<br/>1)Более тяжёлая превоначальная загрузка страницы из-за загрузки кода фреймворка, самого приложения и ресурсов<br/>2)Ваш сервер должен быть сконфигурирован так, чтобы он направлял все запросы к единой точке входа, и переложил обязанности по навигации на сторону клиента.<br/>3)Для отображения содержимого SPA полагается на JavaScript, не все поисковые системы выполняют JS во время индексации, и они могут не увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего приложения. Тем не менее, в большинстве случаев, когда вы создаёте приложения, SEO не является наиболее важным фактором, так как не весь контент должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете либо рендерить своё приложение на стороне сервера, либо использовать такие сервисы, как Prerender, чтобы "рендерить ваш js в браузере, сохранять статический HTML и передавать его поисковым роботам"',
	},
	{
		title: 'Что такое Promise и для чего они нужны?',
		answer:
			'**Promise** — это объект, представляющий результат асинхронной операции (успешный или неудачный). Он позволяет удобно работать с асинхронным кодом, избегая "ада колбэков" (callback hell) и улучшая читаемость.<br/><br/>**Для чего нужны Promise?**<br/>1)Упрощение асинхронного кода (заменяют вложенные колбэки).<br/>2)Обработка ошибок через .catch() вместо try/catch в колбэках.<br/>3)Цепочки вызовов (chaining) — последовательное выполнение асинхронных операций.<br/>4)Параллельное выполнение через Promise.all(), Promise.race() и др.<br/>5)Совместимость с async/await (синтаксический сахар над Promise).<br/><br/>У Promise есть 3 состояния: *pending (ожидание)* — начальное состояние, *fulfilled (выполнено)* — операция завершена успешно, *rejected (отклонено)* — операция завершилась с ошибкой',
	},
	{
		title:
			'Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?',
		answer:
			'Несколько языков, которые компилируются в JavaScript: CoffeeScript, Elm, ClojureScript, PureScript и TypeScript. <br/><br/> **Преимущества**<br/>1)Улучшенная разработка и безопасность типов.<br/>2)Позволяют писать более короткий код, предоставляя синтаксичечкий сахар поверх JS.<br/>3)Дополнительные возможности, которых нет в JS(Опциональная иммутабельность (ReasonML, Elm), Алгебраические типы данных (Rust-подобные enum в TypeScript), Макросы и метапрограммирование (ClojureScript).)<br/>4)Оптимизации на этапе компиляции(Некоторые компиляторы (например, Google Closure Compiler) умеют удалять неиспользуемый код и минимизировать размер бандла.)',
	},
	{
		title:
			'Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?',
		answer:
			'Варианты:<br/>1)for (классический цикл)<br/>`const arr = [1, 2, 3]; for (let i = 0; i < arr.length; i++) { console.log(arr[i]); }`<br/>2)for...of (ES6)<br/>`for (const [index, item] of arr.entries()) { console.log(index, item); }`<br/>3)forEach<br/>`arr.forEach((item, index) => { console.log(index, item); });`<br/>4)map/filter/reduce (Функциональные методы)<br/>`const doubled = arr.map(item => item * 2); const evens = arr.filter(item => item % 2 === 0); const sum = arr.reduce((acc, item) => acc + item, 0);`<br/>5)for...in<br/>`const obj = { a: 1, b: 2 }; for (const key in obj) { if (obj.hasOwnProperty(key)) { console.log(key, obj[key]); } }`<br/>6)Object.keys()/Object.values()/Object.entries() (ES6)<br/>`Object.keys(obj).forEach(key => { console.log(key, obj[key]); });  for (const [key, value] of Object.entries(obj)) { console.log(key, value); }`<br/>7)Object.getOwnPropertyNames()<br/>`Object.getOwnPropertyNames(obj).forEach(key => { console.log(key, obj[key]); });`',
	},
	{
		title: 'Объясните разницу между синхронными и асинхронными функциями.',
		answer:
			'Синхронные функции являются блокирующими, а асинхронные - нет. В синхронных функциях одна операция должна завершиться, прежде чем будет запущена следующая операция. В этом случае скрипт выполняется строго по порядку операций, и выполнение скрипта приостанавливается, если одна из операций занимает очень много времени.<br/><br/>Асинхронные функции обычно принимают callback-функцию в качестве параметра, и выполнение продолжается на следующей строке сразу после вызова асинхронной функции. Callback-функция вызывается только тогда, когда асинхронная операция завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка данных с веб сервера или запросы к базе данных, должны выполняться асинхронно, чтобы основной поток мог продолжать выполнять другие операции вместо блокировки до завершения этой долгой операции (в случае браузеров пользовательский интерфейс будет зависать).',
	},
	{
		title:
			'Что такое цикл событий (event loop)? В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?',
		answer:
			'Асинхронность в JavaScript основана на принципе неблокирующего выполнения операций, что позволяет выполнять длительные задачи (например, сетевые запросы или операции ввода-вывода) без блокировки основного потока выполнения кода.<br/><br/>Асинхронность в JS управляется с помощью **event loop** — механизма, который позволяет двигать выполнение программы между синхронными и асинхронными задачами. Другими словами, это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается с стек вызовов для выполнения.<br/><br/>Stack - "первым пришел, последним вышел" или "последним пришел, первым вышел", что то же самое.<br/>Queue - "первым пришел, первым ушел".',
	},
	{
		title:
			'Объясните разницу при использовании *foo* в function foo() {} и var foo = function() {}.',
		answer:
			'Первое - объявление функции, а второе - функциональное выражение. Ключевое отличие состоит в том, что тело функции при объявлении поднимается наверх, а тело функциональных выражений - нет (они имеют такое же поведение поднятия, что и переменные).',
	},
	{
		title:
			'В чём различие между переменными, созданными при помощи let, var и const?',
		answer:
			'Переменные, объявленные при помощи ключевого слова *var*, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции, — к глобальному объекту. *let* и *const* относятся к блочной области видимости — это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок if-else или цикл for). <br/>*var* позволяет поднимать переменные и на них можно ссылаться в коде до их объявления. <br/>*let*, *const* не позволяют этого и выдают ошибку. Переопределение переменной с помощью var не вызовет ошибку, в отличие от let и const. *let* отличается от *const* тем, что изменять значение *const* нельзя.<br/>`if (true) { var bar = "bar"; let baz = "baz"; const qux = "qux"; } /* bar */ console.log(bar); /* ReferenceError: baz is not defined */ console.log(baz); /* ReferenceError: qux is not defined*/  console.log(qux); `',
	},
	{
		title: 'В чём разница между классом в ES6 и функцией-конструктором в ES5?',
		answer:
			'`/* ES5 функция-конструктор */ function Person(name) { this.name = name; } /* ES6 класс */ class Person { constructor(name) { this.name = name; } }`<br/><br/> Основное отличие в конструкторе возникает при использовании наследования. Если мы хотим создать класс *Student* (который будет являться подклассом класса *Person*) и добавить поле *studentId*, то в дополнение к вышеописанному мы должны сделать следующее: `function Student(name, studentId) { /* Вызов конструктора суперкласса для инициализации производных от суперкласса членов. */ Person.call(this, name); /* Инициализация собственных членов подкласса. */ this.studentId = studentId; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; class Student extends Person { constructor(name, studentId) { super(name); this.studentId = studentId; } }` <br/><br/> Наследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое.',
	},
	{
		title:
			'Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?',
		answer:
			'Преимуществом стрелочных функций является упрощение синтаксиса, необходимого для создания функций, без необходимости использования ключевого слова *function*. *this* внутри стрелочных функций также привязано к замыкающей области видимости, в отличие от обычных функций, где *this* определяется контекстом, в котором они вызываются. Лексически привязанное *this* полезно при вызове callback-функций, особенно в компонентах React.',
	},
	{
		title: 'Дайте определение функции высшего порядка.',
		answer:
			'Функция высшего порядка — это любая функция, которая принимает одну или несколько функций в качестве аргументов, которые она использует для работы с данными, и/или возвращает функцию в качестве результата. Классическим примером является метод *map*, который принимает массив и функцию в качестве аргументов. Затем *map* использует эту функцию для преобразования каждого элемента в массиве, возвращая новый массив с преобразованными данными. Другими популярными примерами в JS являются *forEach*, *filter* и *reduce*.',
	},
	{
		title: 'Можете ли вы привести пример деструктуризации объекта или массива?',
		answer:
			'Деструктуризация - это выражение, доступное в ES6, которое предоставяет краткий и удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные. <br/><br/> **Деструктуризация массива** <br/> `const rgb = [255, 200, 0]; const [red, green, blue] = rgb;` <br/><br/> **Деструктуризация объекта** <br/> `const student = { firstname: "Glad", lastname: "Chinda", country: "Nigeria", }; const { firstname, lastname, country } = student; console.log(firstname, lastname, country); /* Glad Chinda Nigeria */`',
	},
	{
		title:
			'Можете ли вы привести пример каррированной функции (curry function) и в чём их преимущество?',
		answer:
			'**Каррирование** — это паттерн, где функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Каррированная функция должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр. <br/> `function curry(fn) { if (fn.length === 0) { return fn; } function _curried(depth, args) { return function (newArgument) { if (depth - 1 === 0) { return fn(...args, newArgument); } return _curried(depth - 1, [...args, newArgument]); }; } return _curried(fn.length, []); } function add(a, b) { return a + b; } var curriedAdd = curry(add); var addFive = curriedAdd(5); var result = [0, 1, 2, 3, 4, 5].map(addFive); /* [5, 6, 7, 8, 9, 10] */`',
	},
	{
		title:
			'В чём преимущества использования spread оператора и чем он отличается от rest оператора?',
		answer:
			'**Spread** оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к *Object.create*, *slice* или функции библиотеки. <br/> `function putSmthgInAnyArray(arr) { return [...arr, "Smthg"]; } const result = putSmthgInAnyArray([1, 2, 3]);  const person = { name: "Todd", age: 29, }; const copyOfTodd = { ...person };` <br/><br/> **Rest** оператор синтаксиса ES6 позволяет в сокращённом виде указывать неопределённое количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен spread оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов. `function addFiveToABunchOfNumbers(...numbers) { return numbers.map((x) => x + 5); } const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9);`',
	},
	{
		title: 'Каким образом можно обмениваться кодом между файлами?',
		answer:
			'Это зависит от среды выполнения JavaScript.<br/> На клиенте (в среде барузера), пока переменные/функции объявлены в глобальной области видимости (window), все скрипты могут на них ссылаться. В качестве альтернативы, используйте Asynchronous Module Definition (AMD) через RequireJS для модульного подхода.<br/> На сервере (Node.js) обычно используется CommonJS. Каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту *module.exports.* <br/> ES2015 позволяет использовать модульный синтаксис, который призван заменить как AMD, так и CommonJS. В конечном итоге он будет поддерживаться как в браузере, так и в Node.',
	},
	{
		title: 'Для чего используются статические члены класса?',
		answer:
			'Члены статических классов (свойства/методы) не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того, какой экземпляр ссылается на них. Статические свойства обычно являются конфигурационными переменными, а статические методы обычно являются чисто служебынми функциями, которые не зависят от состояния экземпляра.',
	},
	{
		title: 'В чем разница между async и defer?',
		answer:
			'Специальные атрибуты *async* и *defer* используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит. Разница между *async* и *defer*: атрибут *defer* сохраняет относительную последовательность скриптов, а *async* – нет. Кроме того, *defer* всегда ждёт, пока весь HTML-документ будет готов, а *async* – нет.',
	},
	{
		title:
			'В чём разница между изменяемым (mutable) и неизменяемым (immutable) объектом?',
		answer:
			'**Изменяемый объект** - это объект, состояние которого может быть изменено после его создания. **Неизменяемый объект** - это объект, состояние которого не может быть изменено после его создания. <br/> В JavaScript: <br/> 1) Неизменяемые типы: Number, String, Boolean, null, undefined<br/> 2)Изменяемые типы: все объекты по умолчанию (Object, Array, Map, Set и т.д.) <br/><br/> Неизменяемость может быть достигнута с помощью: <br/> 1)Object.freeze() - предотвращает добавление новых свойств и изменение существующих <br/> 2)Object.seal() - предотвращает добавление новых свойств, но позволяет изменять существующие <br/>3) Использование библиотек, таких как Immutable.js',
	},
];
